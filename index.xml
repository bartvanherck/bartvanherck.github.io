<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing is Fun</title>
    <link>http://bartvanherck.github.io/</link>
    <description>Recent content on Testing is Fun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 29 Jun 2019 18:00:00 +0100</lastBuildDate>
    
	<atom:link href="http://bartvanherck.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>What I read</title>
      <link>http://bartvanherck.github.io/blog/20190629_readed/</link>
      <pubDate>Sat, 29 Jun 2019 18:00:00 +0100</pubDate>
      
      <guid>http://bartvanherck.github.io/blog/20190629_readed/</guid>
      <description>&lt;p&gt;Some documents that are really usefull to read:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.satisfice.com/tools/htsm.pdf&#34;&gt;Heuristic Test Strategy Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.satisfice.com/rst.pdf&#34;&gt;Rapid Software Testing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.satisfice.com/rst-appendices.pdf&#34;&gt;Rapid Software Testing Appendices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.satisfice.com/articles/et-article.pdf&#34;&gt;Exploratory Testing Explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thetesteye.com/papers/TheLittleBlackBookOnTestDesign.pdf&#34;&gt;The Little Black Book on Test Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://testobsessed.com/wp-content/uploads/2011/04/testheuristicscheatsheetv1.pdf&#34;&gt;Test Heuristic Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happy reading!&lt;/p&gt;
<br /><div><a href="http://bartvanherck.github.io/blog/20190629_readed/">Read the complete article.</a></div>
      </description>
    </item>
    
    <item>
      <title>Reasons to create Unit Tests</title>
      <link>http://bartvanherck.github.io/blog/20190614_reasons/</link>
      <pubDate>Fri, 14 Jun 2019 18:00:00 +0100</pubDate>
      
      <guid>http://bartvanherck.github.io/blog/20190614_reasons/</guid>
      <description>&lt;p&gt;Writing unit tests for API&amp;rsquo;s is a waste of time. A waste of time? Yes, I am developing an API. The API is not stable yet. Today I need to rewrite some calls and now all my tests fail. I need to update all those unit tests. If I did not have to write tests, my code was already finished.&lt;/p&gt;
&lt;p&gt;Yes, it is. By changing an interface or API, you need to update the existing tests. It is possible that many tests needs an update. Updating tests takes some time and costs something. Does this mean that writing unit tests is a waste of time?&lt;/p&gt;
&lt;h3 id=&#34;unit-testing-is-like-walking&#34;&gt;Unit Testing is like walking.&lt;/h3&gt;
&lt;p&gt;Unit testing is like trying to do a long distance walk. You want to walk 100 km in 24 hours. You start to train. Each weekend you go for a walk. It goes well in the beginning. You can walk 10 km, a few weeks later you walk 20 km. Then you are training to go more kilometres. After 25 km, you feel pain in your feet. You are thinking: &amp;ldquo;Why am I doing this? Why am I hurting myself?&amp;rdquo;  That pains stays several weeks.&lt;/p&gt;
&lt;p&gt;By the time it is getting better, there is something else that has more priority. Some people have their birthday. The party is on a day that you planned to go for a walk. You skip. The week after that something else interferes with your walking plans. After a few weeks without any walk you decide to go again. Ambitious as you are, you start with 30 kilometres. But everything hurts after 20 kilometres. You ask yourself again why you are doing it?&lt;/p&gt;
&lt;p&gt;While you walk, you see other walkers. They never had problems with pain and go much faster as you. They also go twice the distance as you are doing. How do they do that? But they do not have as many friends as you have. And their friends never celebrate their birthdays. They have much more time to walk.&lt;/p&gt;
&lt;p&gt;You have two options. The first option is to quit. You conclude that you do not have anything in common with them. In the end you conclude that a long distance walk is nothing for you. You never walk again.  The second option is to start over and try until you manage to walk the distance that you want to walk. The second option is the hardest, but in the end it was worth the effort.&lt;/p&gt;
&lt;h3 id=&#34;safety-net&#34;&gt;Safety net&lt;/h3&gt;
&lt;p&gt;Unit testing is not easy. You can start to create unit tests and create each day more unit tests. In the end you have many unit tests. No, that was not our initial problem. The problem was that the developer needs to update too many unit tests.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;api_overview.jpg&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;Drawing&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;You have a system with an API. The API does probably have more than one call. If you do not write any tests for the API&amp;rsquo;s, none of them have any tests. What happens if you update a function that also has some impact on an other function? What happens if you as developer make a mistake and the other API&amp;rsquo;s are failing? Do you want to know while you are developing that your other interfaces are failing? I suppose you do. If you do not have any unit tests on API level or in another part, your do not know if something else in the system is failing. Unit tests are the safety net for the existing functionality that you do not touch.&lt;/p&gt;
&lt;h3 id=&#34;design&#34;&gt;Design&lt;/h3&gt;
&lt;p&gt;Unit testing has more advantages. By creating unit tests on an interface, you are thinking about how you should use that interface (or API). Maybe the API is not that useful when you use it. The design of the API was not good. The usage of the API via the unit tests proves that.&lt;/p&gt;
&lt;h3 id=&#34;stable&#34;&gt;Stable&lt;/h3&gt;
&lt;p&gt;Unit tests test a small piece of code. That means that the tests are more stable than an automated user interface test. User interface tests are more flaky. They tend to fail without any reason. They also have problems with variations on the network speed. They are more complex to debug when they fail. The code that they cover is bigger. In case a unit test fails, the developer does not have to debug in most cases. He knows which part of the code a test covers.&lt;/p&gt;
&lt;h3 id=&#34;documentation&#34;&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Write some documentation. Your other colleagues do also need to know how your code looks like. Unit test are ideal for documenting code. A developer can look at a unit test to see how to call some part of the code. You do not have to document the usage anymore. It is in the set of unit tests.&lt;/p&gt;
&lt;h3 id=&#34;speed&#34;&gt;Speed&lt;/h3&gt;
&lt;p&gt;The fastest tests are unit tests. The execution of one tests is in the range of milliseconds. In the same time as you run one end to end test, you can do a lot of unit tests. End to end tests are slow because they imitate  a user. Because of the fast execution times there is a fast feedback. You as developer can run the tests during the development process. You will check if the system is still performing like it was before your changes. Faster feedback is cheaper, everybody knows it by now. You will find bugs earlier in the development cycle by the unit tests. The cost of a bug is much lower.&lt;/p&gt;
&lt;h3 id=&#34;continuous-integration-server&#34;&gt;Continuous Integration Server&lt;/h3&gt;
&lt;p&gt;Writing unit tests is a very good idea. It is better to run them in an automated way on a continuous integration server. Then the server executes the tests as soon as you put the new code in version control. Everybody notices it when the tests are failing on the continuous integration server. This is an advantage. Developers will fix the failing tests much faster. Nobody likes a failing build.&lt;/p&gt;
&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;
&lt;p&gt;Writing unit tests is a good way of working. In the beginning it is hard. It is worth the effort. The end user will be much happier with a product that has less bugs.&lt;/p&gt;
<br /><div><a href="http://bartvanherck.github.io/blog/20190614_reasons/">Read the complete article.</a></div>
      </description>
    </item>
    
    <item>
      <title>Test Reports are Dead</title>
      <link>http://bartvanherck.github.io/blog/20190613_reports/</link>
      <pubDate>Thu, 13 Jun 2019 18:00:00 +0100</pubDate>
      
      <guid>http://bartvanherck.github.io/blog/20190613_reports/</guid>
      <description>&lt;p&gt;At the testnet conference, I attended to a talk of Gerlof Hoekstra. According to him our test documentation is not readed by anyone, or maybe even misinterpreted. This because they only contains figures and no real story. It looks that he has remembered the previous talk, but he has a point. Should a Tester give an advice to our developers to release or should the content of a report be so clear that everyone can decide for himself if the product can be released?&lt;/p&gt;
&lt;p&gt;To have documentation that does matter, that is usefull, we should act like we are the reader. What does the reader wants to know? Take for example a weather forecast. What does the recipient want to know? He wants to know if it is going to rain tomorrow or if the sun is shining. So a prediction of the future. The weather report is short and visible, with maps and symbols.&lt;/p&gt;
&lt;p&gt;Why should we not use that kind of things?&lt;/p&gt;
&lt;p&gt;So instead of a report, it is better to have a stream of information. So Why not make information available at any time. But how detailed we want to have our reporting? Depends on the reader.
Some of them wants to know if a requirement or user story is ready. Others want to know more detailed. This can also be put in a kind of daily blog post that we can share across our organisations.&lt;/p&gt;
&lt;p&gt;This idea is a nice one I think. Why not blog more in the company to share ideas or forecasts of the project?&lt;/p&gt;
<br /><div><a href="http://bartvanherck.github.io/blog/20190613_reports/">Read the complete article.</a></div>
      </description>
    </item>
    
    <item>
      <title>Swiping on a touch screen</title>
      <link>http://bartvanherck.github.io/blog/20190612_swiping/</link>
      <pubDate>Wed, 12 Jun 2019 18:00:00 +0100</pubDate>
      
      <guid>http://bartvanherck.github.io/blog/20190612_swiping/</guid>
      <description>&lt;p&gt;We had already a few months a problem on the machines touchscreen that our interface behaved differently with a finger swipe as with a mouse drag and drop. The problem was that swiping from left to right was navigating to the previous page. And swiping the other way around was taking us to the next page.&lt;/p&gt;
&lt;p&gt;Because a customer does not need to know that our interface is in fact a html page, this is unwanted behavior from user testings point of view. In the options of Chrome itself I could not find any options that could explain this behavior.&lt;/p&gt;
&lt;p&gt;But there is a solution. Just start chrome or chromium with a command line switch.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;  --overscroll-history-navigation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Did you know that chrome has a lot of command line parameters? Look at &lt;a href=&#34;http://peter.sh/experiments/chromium-command-line-switches/&#34;&gt;Peter Beverloo’s page&lt;/a&gt; for an overview.&lt;/p&gt;
&lt;p&gt;You see, as a tester you also need to think how we can solve bugs, because not all bugs are code related.&lt;/p&gt;
<br /><div><a href="http://bartvanherck.github.io/blog/20190612_swiping/">Read the complete article.</a></div>
      </description>
    </item>
    
  </channel>
</rss>